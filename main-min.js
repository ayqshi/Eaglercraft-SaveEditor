let epkFile=null,extractedFiles=new Map,activeFile={name:null,buffer:null,nbtParsed:null};const epkFileInput=document.getElementById("epkFileInput"),decompileButton=document.getElementById("decompileButton"),repackButton=document.getElementById("repackButton"),statusMessageDiv=document.getElementById("statusMessage"),fileListContainer=document.getElementById("fileList"),fileContentEditor=document.getElementById("fileContentEditor"),saveChangesButton=document.getElementById("saveChangesButton"),messageBox=document.getElementById("messageBox"),messageTitle=document.getElementById("messageTitle"),messageContent=document.getElementById("messageContent"),messageCloseBtn=document.getElementById("messageCloseBtn");function showStatusMessage(e,t){statusMessageDiv.textContent=e,statusMessageDiv.className="status-message "+(t?"status-"+t:""),statusMessageDiv.classList.remove("hidden")}function showMessageBox(e,t,n="info"){messageTitle.textContent=e,messageContent.textContent=t,messageBox.style.display="block"}function clearFileListDisplay(){fileListContainer.innerHTML='<p class="text-gray-400 p-4 text-center">Upload an EPK file to see its contents here.</p>'}function resetFileEditor(){fileContentEditor.value="",fileContentEditor.placeholder="Select a file from the left to view/edit its content.",fileContentEditor.disabled=!0,saveChangesButton.disabled=!0,activeFile={name:null,buffer:null,nbtParsed:null,wasGzipped:!1};const e=fileListContainer.querySelector(".file-list-item.selected");e&&e.classList.remove("selected")}function displayExtractedFiles(e){clearFileListDisplay(),0!==e.size?e.forEach(((e,t)=>{const n=document.createElement("div");n.className="file-list-item",n.dataset.filename=t;let r=t.split(".").pop().toLowerCase()||"binary",s="bg-gray-600";t.endsWith(".dat")?s="bg-purple-700":t.match(/\.(png|jpg|jpeg|gif|bmp|webp)$/i)?s="bg-blue-600":t.match(/\.(txt|json|yml|xml|html|css|js)$/i)?s="bg-green-600":t.match(/\.(ogg|wav|mp3)$/i)&&(s="bg-red-600"),n.innerHTML=`\n                <span>${t}</span>\n                <span class="file-type-badge ${s}">${r.toUpperCase()}</span>\n            `,n.addEventListener("click",(()=>{selectFileForEditing(t,e)})),fileListContainer.appendChild(n)})):fileListContainer.innerHTML='<p class="text-gray-400 p-4 text-center">No files extracted.</p>'}async function selectFileForEditing(e,t){const n=fileListContainer.querySelector(".file-list-item.selected");n&&n.classList.remove("selected");const r=fileListContainer.querySelector(`[data-filename="${e}"]`);r&&r.classList.add("selected"),showStatusMessage(`Loading ${e} into editor...`,"info"),fileContentEditor.disabled=!1,saveChangesButton.disabled=!0,activeFile={name:e,buffer:t,nbtParsed:null,wasGzipped:!1};try{if(e.endsWith(".dat"))await viewNBTData(e,t);else if(e.match(/\.(txt|json|yml|xml|html|css|js|glsl)$/i)){const n=new TextDecoder("utf-8",{fatal:!0});try{activeFile.nbtParsed=null,fileContentEditor.value=n.decode(t),saveChangesButton.disabled=!1,showStatusMessage(`Loaded ${e} as text.`,"success")}catch(n){console.warn(`Failed to decode ${e} as UTF-8, attempting Base64:`,n),fileContentEditor.value=`// Binary file (UTF-8 decode failed), showing as Base64. Edit carefully!\n${atob(arrayBufferToBase64(t))}`,saveChangesButton.disabled=!1,showStatusMessage(`Loaded ${e} as Base64 (UTF-8 decode failed).`,"warning")}}else activeFile.nbtParsed=null,fileContentEditor.value=`// Binary file, showing as Base64. Edit carefully!\n${arrayBufferToBase64(t)}`,saveChangesButton.disabled=!1,showStatusMessage(`Loaded ${e} as Base64.`,"info")}catch(t){console.error(`Error loading ${e}:`,t),fileContentEditor.value=`Error loading file: ${t.message}`,fileContentEditor.disabled=!0,saveChangesButton.disabled=!0,showStatusMessage(`Error loading ${e}.`,"error")}}function arrayBufferToBase64(e){let t="";const n=new Uint8Array(e),r=n.byteLength;for(let e=0;e<r;e++)t+=String.fromCharCode(n[e]);return btoa(t)}function base64ToArrayBuffer(e){const t=atob(e),n=t.length,r=new Uint8Array(n);for(let e=0;e<n;e++)r[e]=t.charCodeAt(e);return r.buffer}function nbtTagToObject(e){if(!e)return null;if(e.type===NBT.Type.TAG_COMPOUND&&void 0!==e._name&&null!==e._name){const t={};for(const n in e._value)e._value.hasOwnProperty(n)&&(t[n]=nbtTagToObject(e._value[n]));return{_rootName:e._name,_type:e.typeName,_value:t}}if(e.type===NBT.Type.TAG_BYTE_ARRAY)return{_type:e.typeName,_value:Array.from(new Uint8Array(e._value))};if(e.type===NBT.Type.TAG_INT_ARRAY)return{_type:e.typeName,_value:Array.from(new Int32Array(e._value))};if(e.type===NBT.Type.TAG_LONG)return{_type:e.typeName,_value:e._long().toString()};if(e.type===NBT.Type.TAG_LIST)return{_type:e.typeName,_listType:e.listTypeName,_value:e._value.map(nbtTagToObject)};if(e.type===NBT.Type.TAG_COMPOUND){const t={_type:e.typeName};for(const n in e._value)e._value.hasOwnProperty(n)&&(t[n]=nbtTagToObject(e._value[n]));return t}return e.hasOwnProperty("valueOf")?e.valueOf():e}function objectToNbtTag(e,t=""){if(null==e)return null;if(e&&"object"==typeof e&&"compound"===e._type&&void 0!==e._rootName&&void 0!==e._value){const t=e._rootName,n=e._value,r=new NBT.NBTTagCompound({},t);for(const e in n)if(n.hasOwnProperty(e)&&!e.startsWith("_")){const t=objectToNbtTag(n[e],e);t&&r.put(e,t)}return r}if("object"==typeof e&&null!==e&&e._type)switch(e._type){case"byteArray":const n=e._value.length>0?new Uint8Array(e._value):new Uint8Array(0);return new NBT.NBTTagByteArray(n.buffer,t);case"intArray":return new NBT.NBTTagIntArray(new Int32Array(e._value).buffer,t);case"long":return new NBT.NBTTagLong(e._value,t);case"list":const r=e._value.map((e=>objectToNbtTag(e,"")));let s=NBT.Type.TAG_END;return r.length>0&&r[0]?s=r[0].type:e._listType&&(s=NBT.Type[e._listType.toUpperCase()]),new NBT.NBTTagList(s,r,t);case"compound":const a=new NBT.NBTTagCompound({},t);for(const t in e)if(e.hasOwnProperty(t)&&!t.startsWith("_")){const n=objectToNbtTag(e[t],t);n&&a.put(t,n)}return a}else{if("number"==typeof e)return Number.isInteger(e)?e>=NBT.NBTTagByte.MIN_VALUE&&e<=NBT.NBTTagByte.MAX_VALUE?new NBT.NBTTagByte(e,t):e>=NBT.NBTTagShort.MIN_VALUE&&e<=NBT.NBTTagShort.MAX_VALUE?new NBT.NBTTagShort(e,t):e>=NBT.NBTTagInt.MIN_VALUE&&e<=NBT.NBTTagInt.MAX_VALUE?new NBT.NBTTagInt(e,t):new NBT.NBTTagLong(e,t):new NBT.NBTTagDouble(e,t);if("string"==typeof e)return new NBT.NBTTagString(e,t);if("boolean"==typeof e)return new NBT.NBTTagByte(e?1:0,t);if(Array.isArray(e)){const n=e.map((e=>objectToNbtTag(e,"")));let r=NBT.Type.TAG_END;return n.length>0&&n[0]&&(r=n[0].type),new NBT.NBTTagList(r,n,t)}if("object"==typeof e&&null!==e){const n=new NBT.NBTTagCompound({},t);for(const t in e)if(e.hasOwnProperty(t)){const r=objectToNbtTag(e[t],t);r&&n.put(t,r)}return n}}return console.warn("Could not convert JS object to NBT tag:",e),null}async function viewNBTData(e,t){showStatusMessage(`Attempting to parse NBT for ${e}...`,"info");let n=new Uint8Array(t);activeFile.wasGzipped=!1;try{if(n.length>2&&31===n[0]&&139===n[1])try{n=pako.ungzip(n),activeFile.wasGzipped=!0,showStatusMessage(`Decompressed GZIP for ${e}.`,"info")}catch(t){console.warn(`Could not decompress ${e} with GZIP. Assuming it's uncompressed or invalid GZIP.`,t)}const s=NBT.readTag(n.buffer);activeFile.nbtParsed=s;function r(e){if(e instanceof ArrayBuffer){const t=new DataView(e);switch(e.byteLength){case 1:return t.getInt8(0);case 2:return t.getInt16(0,!1);case 4:return t.getInt32(0,!1);case 8:const n=t.getUint32(0,!1);return 4294967296*t.getInt32(4,!1)+n;default:return e}}return e}const a=function e(t){if("object"==typeof t&&null!==t)for(const n in t)t.hasOwnProperty(n)&&(t[n]=r(t[n]),"object"==typeof t[n]&&null!==t[n]&&e(t[n]));return t}(nbtTagToObject(s));fileContentEditor.value=JSON.stringify(a,null,2),saveChangesButton.disabled=!1,showStatusMessage(`Successfully parsed NBT for ${e}.`,"success"),console.log("NBT Data Structure:",a)}catch(n){console.error(`Error parsing NBT for ${e}:`,n),fileContentEditor.value=`Error: Could not parse NBT data for ${e}.\n\nRaw data (Base64):\n${arrayBufferToBase64(t)}`,fileContentEditor.disabled=!0,saveChangesButton.disabled=!0,showStatusMessage(`Error parsing NBT for ${e}. See console for details.`,"error")}}async function decryptEpk(e){showStatusMessage("Attempting to decrypt EPK file...","info"),new DataView(e);let t=0;const n=new Map;let r=!1;try{const s=new Uint8Array(e.slice(t,t+8));t+=8;const a=new Uint8Array([69,65,71,80,75,71,36,36]),i=new Uint8Array([69,65,71,80,75,71,33,33]);if(!arraysEqual(s,a))throw arraysEqual(s,i)?(r=!0,new Error("Legacy EPK format detected. This decompiler currently only supports 'ver2.x' EPK files.")):new Error("Unrecognized EPK file header.");const o=new Uint8Array([58,58,58,89,69,69,58,62]);if(!arraysEqual(new Uint8Array(e.slice(e.byteLength-8,e.byteLength)),o))throw new Error("EPK file is missing EOF code (:::YEE:>)");const l=e.slice(8,e.byteLength-8),c=new DataView(l);let u=0,d=c.getUint8(u++);const f=new Uint8Array(l.slice(u,u+d));u+=d;const g=new TextDecoder("ascii").decode(f);if(!g.startsWith("ver2."))throw new Error(`Unknown or invalid EPK version: ${g}`);d=c.getUint8(u++),u+=d,d=c.getUint16(u),u+=2,u+=d,u+=8;let p=c.getInt32(u);u+=4;const y=String.fromCharCode(c.getUint8(u++));let w;const h=l.slice(u);switch(y){case"G":showStatusMessage("Detected GZIP compression. Decompressing...","info"),w=pako.ungzip(new Uint8Array(h));break;case"Z":showStatusMessage("Detected ZLIB compression. Decompressing...","info"),w=pako.inflate(new Uint8Array(h));break;case"0":showStatusMessage("Detected no compression.","info"),w=new Uint8Array(h);break;default:throw new Error(`Invalid or unsupported EPK compression: ${y}`)}const T=new DataView(w.buffer);let m=0;for(new CRC32;p>0;){const e=new Uint8Array(w.buffer.slice(m,m+4));m+=4;const t=new TextDecoder("ascii").decode(e);if("END$"===t){p=0;break}d=T.getUint8(m++);const r=new Uint8Array(w.buffer.slice(m,m+d));m+=d;const s=new TextDecoder("ascii").decode(r);let a;if(d=T.getInt32(m),m+=4,"FILE"===t){if(d<5)throw new Error(`File '${s}' is incomplete (no crc)`);if(T.getInt32(m),m+=4,a=w.buffer.slice(m,m+d-5),m+=d-5,":"!==String.fromCharCode(T.getUint8(m++)))throw new Error(`File '${s}' is incomplete (missing colon)`)}else a=w.buffer.slice(m,m+d),m+=d;if(">"!==String.fromCharCode(T.getUint8(m++)))throw new Error(`Object '${s}' is incomplete (missing greater than)`);n.set(s,a),p--}return 0!==p&&console.warn(`Unexpectedly ended decryption with ${p} files remaining.`),showStatusMessage(`EPK file decrypted successfully. Found ${n.size} files.`,"success"),n}catch(e){throw showStatusMessage(`EPK decryption failed: ${e.message}`,"error"),console.error("EPK Decryption Error:",e),e}}async function encryptEpk(e){showStatusMessage("Attempting to re-pack and encrypt EPK file...","info");try{const t=new ByteArrayOutputStream;t.writeString("EAGPKG$$","ascii");const n="ver2.0";t.writeUint8(n.length),t.writeString(n,"ascii");const r=epkFile?epkFile.name:"unknown.epk";t.writeUint8(r.length),t.writeString(r,"ascii");const s=new Date,a=`\n\n # Eagler EPK v2.0 - Generated by EaglerBinaryTools\n # update: on ${new Intl.DateTimeFormat("en-US",{month:"2-digit",day:"2-digit",year:"numeric"}).format(s)} at ${new Intl.DateTimeFormat("en-US",{hour:"2-digit",minute:"2-digit",second:"2-digit",hour12:!1}).format(s)}\n\n`;t.writeUint16(a.length),t.writeString(a,"ascii"),t.writeLong(s.getTime()),t.writeInt(e.size+1);const i="G";t.writeUint8(i.charCodeAt(0));const o=new ByteArrayOutputStream;o.writeString("HEAD","ascii");const l="file-type";o.writeUint8(l.length),o.writeString(l,"ascii");const c="epk/resources";o.writeInt(c.length),o.writeString(c,"ascii"),o.writeUint8(">".charCodeAt(0));const u=new CRC32;for(const[t,n]of e.entries()){const e=new Uint8Array(n);u.reset(),u.update(e);const r=u.getValue();o.writeString("FILE","ascii");let s=t.replace(/\\/g,"/");s.startsWith("/")&&(s=s.substring(1)),o.writeUint8(s.length),o.writeString(s,"ascii"),o.writeInt(e.length+5),o.writeInt(r),o.writeBytes(e),o.writeUint8(":".charCodeAt(0)),o.writeUint8(">".charCodeAt(0))}let d;return o.writeString("END$","ascii"),d="G"===i?pako.gzip(o.toByteArray()):"Z"===i?pako.deflate(o.toByteArray()):o.toByteArray(),t.writeBytes(d),t.writeString(":::YEE:>","ascii"),showStatusMessage("EPK file re-packed and encrypted successfully.","success"),t.toByteArray().buffer}catch(e){throw showStatusMessage(`EPK re-packing failed: ${e.message}`,"error"),console.error("EPK Encryption Error:",e),e}}epkFileInput.addEventListener("change",(e=>{epkFile=e.target.files[0],epkFile?(showStatusMessage(`File selected: ${epkFile.name}`,"info"),decompileButton.disabled=!1,repackButton.disabled=!0,clearFileListDisplay(),resetFileEditor()):(showStatusMessage("No file selected.","warning"),decompileButton.disabled=!0,repackButton.disabled=!0)})),decompileButton.addEventListener("click",(async()=>{if(!epkFile)return void showMessageBox("Error","Please select an EPK file first.","error");showStatusMessage("Reading file...","info"),decompileButton.disabled=!0,repackButton.disabled=!0,resetFileEditor();const e=new FileReader;e.onload=async e=>{try{const t=e.target.result;extractedFiles=await decryptEpk(t),displayExtractedFiles(extractedFiles),repackButton.disabled=!1,decompileButton.disabled=!1}catch(e){console.error("Decryption failed:",e),showStatusMessage(`Decryption failed: ${e.message}`,"error"),decompileButton.disabled=!1}},e.onerror=e=>{showStatusMessage(`Error reading file: ${e.target.error.message}`,"error"),decompileButton.disabled=!1},e.readAsArrayBuffer(epkFile)})),saveChangesButton.addEventListener("click",(async()=>{showStatusMessage("This feature is not yet available. If you wish to contribute to coding this app, you can find open source code at https://github.com/ayqshi","error")})),repackButton.addEventListener("click",(async()=>{showStatusMessage("This feature is currently broken. If you wish to contribute to coding this app, you can find open source code at https://github.com/ayqshi","error")})),messageCloseBtn.addEventListener("click",(()=>{messageBox.style.display="none"}));class ByteArrayOutputStream{constructor(){this.buffer=[],this.offset=0}writeUint8(e){const t=new Uint8Array(1);new DataView(t.buffer).setUint8(0,e),this.buffer.push(t.buffer),this.offset++}writeUint16(e){const t=new Uint8Array(2);new DataView(t.buffer).setUint16(0,e,!1),this.buffer.push(t.buffer),this.offset+=2}writeInt(e){const t=new Uint8Array(4);new DataView(t.buffer).setInt32(0,e,!1),this.buffer.push(t.buffer),this.offset+=4}writeLong(e){const t=Long.fromValue(e),n=new Uint8Array(8),r=new DataView(n.buffer);r.setInt32(0,t.high,!1),r.setInt32(4,t.low,!1),this.buffer.push(n.buffer),this.offset+=8}writeString(e,t="utf8"){const n=new TextEncoder(t).encode(e);this.buffer.push(n.buffer),this.offset+=n.length}writeBytes(e){this.buffer.push(new Uint8Array(e).buffer),this.offset+=new Uint8Array(e).byteLength}toByteArray(){if(0===this.buffer.length)return new Uint8Array(0);const e=this.buffer.reduce(((e,t)=>e+t.byteLength),0),t=new Uint8Array(e);let n=0;return this.buffer.forEach((e=>{t.set(new Uint8Array(e),n),n+=e.byteLength})),t}}function arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}class CRC32{constructor(){this.crc=-1,this.table=new Uint32Array(256);for(let e=0;e<256;e++){let t=e;for(let e=0;e<8;e++)t=1&t?3988292384^t>>>1:t>>>1;this.table[e]=t}}update(e){let t=this.crc;for(let n=0;n<e.length;n++)t=t>>>8^this.table[255&(t^e[n])];this.crc=t}getValue(){return-1^this.crc}reset(){this.crc=-1}}document.addEventListener("DOMContentLoaded",(()=>{decompileButton.disabled=!0,repackButton.disabled=!0,saveChangesButton.disabled=!0,fileContentEditor.disabled=!0,showStatusMessage("Select an EPK file to get started.","info")}));